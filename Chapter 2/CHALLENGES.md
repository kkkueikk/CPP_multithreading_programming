## ðŸ”¹ C++ Multithreading Challenges

| Filename | Task | Challenge Question | Completed | My Notes |
|----------|------|-------------------|-----------|----------|
| ThreadJoinVsDetach.cpp | Write a program that spawns two threads: (1) One joined before main exits, (2) One detached. Print messages in both threads to see the difference in behavior. | What happens if you forget to `join()` or `detach()`? | Yes | Join or detach the thread before `std::terminate()` is called. Detached threads are often long running daemon threads that pass ownership to C++ runtime library. |
| DanglingReference.cpp | Write a function that starts a thread using a local buffer (like `oops()` example). First, reproduce the undefined behavior case with `detach()`. Then, fix it by passing a `std::string` instead. | Why does the original code cause UB? | Yes | When thread is detached, the `oops` function is likely destroyed before buffer is converted to std::string, leading to undefined behavior. Thread function must be self-contained with all needed data. |
| PassByReference.cpp | Create a struct `widget_data` with a simple integer counter. Write a thread function that increments it. Try passing by value (copy) and by reference (`std::ref`). Print the difference in results. | Why does passing by value not update the original object? | Yes | Arguments are COPIED into thread's internal storage by default. Use `std::ref()` to create reference wrapper that tells `std::thread` "don't copy this, pass the actual reference to the original object." |
| UniqueVsSharedPtrThread.cpp | Create a resource manager (just an integer counter). Start two threads: (1) One takes ownership via `std::unique_ptr` (moved), (2) Another shares ownership via `std::shared_ptr`. | What differences do you see in behavior and ownership semantics? How is `std::shared_ptr` initialized with non-copyable types like `std::thread`? | No | unique_ptr: single owner, not copyable, movable, low overhead. shared_ptr: multiple owners, copyable, movable, higher overhead due to reference counting. |
| ThreadOwnershipMove.cpp | Write a function that spawns a thread and **returns it** to the caller. Move the returned thread into another `std::thread` variable in `main()`. Try assigning without `move` and observe the compiler error. | Why must `std::thread` be movable but not copyable? | Yes | Threads are movable but not copyable. Move support facilitates storing threads in containers, allows returning threads from functions, and enables RAII. If destination thread is joinable, `std::terminate()` will be called. |
| ThreadVector.cpp | Use `std::vector<std::thread>` to spawn N threads that each print their thread ID. Use `std::thread::hardware_concurrency()` to decide N. | What happens if you create more threads than your hardware concurrency? | Yes | Oversubscription causes slow performance due to too many context switches and resource not fully utilized. `std::thread::hardware_concurrency()` returns [0, number of threads that can truly run concurrently]. |
| ThreadIdentification.cpp | Write a program that spawns two threads and prints: (1) Each thread's ID (`get_id()`), (2) The main thread's ID. Compare `std::thread::id()` of an empty `std::thread` with an active one. | What's the difference between a default-constructed `id` and a valid one? | Yes | Thread ID can be obtained via `<thread_name>.get_id()` or `std::this_thread::get_id()`. Default-constructed thread id represents no associated thread. |
| RAIIJoin.cpp | Implement a small RAII wrapper class `ThreadGuard` that: (1) Takes a `std::thread&` in its constructor, (2) Calls `join()` in the destructor if the thread is joinable. Test it by spawning a thread that prints a message. | Why does RAII help prevent program crashes in multithreading? | No | RAII: Acquire resource in constructor, release resource in destructor. Ensures thread is properly joined even if exceptions occur, preventing `std::terminate()` calls. |
| ReturnResultThread.cpp | Write a function that launches a thread to compute a factorial and stores the result in a shared vector. Make sure to `join()` before reading results. Then, try rewriting using `std::promise`/`std::future`. | What's the drawback of using a raw reference to results compared to futures? | No | Raw references require manual synchronization and careful lifetime management. Futures provide type-safe, exception-safe communication between threads (Chapter 4). |
